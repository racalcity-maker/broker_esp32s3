# План оптимизаций памяти

## MQTT‑брокер (`components/mqtt_core`)
- **Перенести retain‑кэш и сессии в PSRAM.** Добавить `EXT_RAM_ATTR` (или соответствующий атрибут IDF 5.3) к `s_retain` и `s_sessions`, чтобы десятки килобайт массивов ушли из внутренней DRAM.
- **Динамический retain.** Вместо фиксированных `MQTT_RETAIN_MAX`×`MQTT_MAX_PAYLOAD` выделять payload через `heap_caps_malloc(MALLOC_CAP_SPIRAM)`, а число слотов подстроить под реальную нагрузку.
- **Ограничить подписки.** Уменьшить `MQTT_MAX_SUBS` до фактически используемого значения и/или хранить темы в динамическом списке.
- **Общий буфер пакетов.** `pkt[MQTT_MAX_PACKET]` сейчас лежит на стеке каждого клиента. Вынести в `heap_caps_malloc` (SPIRAM) или сделать общий буфер с мьютексом, чтобы ещё уменьшить размер стека.
- **Единая задача для клиентов.** Долгосрочно — перейти на модель «одна задача + select()», чтобы убрать пер‑клиентские стеки полностью.

## Web UI (`components/web_ui`)
- **Стриминговые ответы.** `/api/files`, `/api/status`, `/api/pictures/config` формируют большие JSON‑буферы. Переписать на `httpd_resp_send_chunk()` и избавить DRAM от временных 4+ КБ.
- **WAV‑метаданные опционально.** Парсинг заголовка WAV при листинге приносит минимум пользы и задержку. Либо отключить, либо вынести в отдельный запрос.
- **Все временные буферы в PSRAM.** Где нужны большие массивы (например, формирование HTML/JSON), использовать `heap_caps_malloc(MALLOC_CAP_SPIRAM)` и освобождать `heap_caps_free`.

## Audio / общие рекомендации
- Проверить `audio_player` на наличие крупных статических/heap‑буферов и перевести их в PSRAM.
- Просмотреть стеки остальных задач (`audio`, `web`, `network`) через `uxTaskGetStackHighWaterMark()` и уменьшить до фактических значений.
- Включить в `sdkconfig` опции `CONFIG_SPIRAM_ALLOW_BSS_SEG_EXTERNAL_MEMORY` и `CONFIG_SPIRAM_ALLOW_STACK_EXTERNAL_MEMORY`, если код готов работать с PSRAM по умолчанию.

Эти шаги позволят снизить давление на основную DRAM и увеличить запас свободной памяти даже при одновременной работе нескольких клиентов и аудио. 

## Device Manager / Automation
- **Единый формат конфигурации.** Новый `device_manager` уже резервирует структуру (устройства, вкладки, сценарии). Следующий шаг — добавить текстовый формат (JSON/YAML) и валидатор, чтобы можно было редактировать конфиг offline.
- **NVS + SD.** После правок UI следует писать изменения в файл на SD, а затем синхронизировать с NVS (`device_manager_save_snapshot()` и `device_manager_sync_file()`). Нужно продумать резервные копии и откат.
- **HTTP API.** Сейчас `/api/devices/config` возвращает только краткое описание. План: расширить JSON до полного списка устройств/шагов и реализовать `/api/devices/apply`, который принимает новую конфигурацию, валидирует и применяет её без перезагрузки.
- **MQTT/сценарный исполнитель.** Когда конфигурация станет динамической, `mqtt_core` должен получать таблицу подписок из `device_manager`, а новый «executor» — исполнять шаги (publish, play track, wait flags, loops) с хранением контекста в PSRAM.
- **UI вкладки.** На отдельной странице UI потребуется редактор устройств: CRUD устройств, настройка вкладок (максимум 12) и конструктор сценариев с задержками/циклами. Аудио‑вкладка остаётся статичной.
- **Event Bus.** После применения новой конфигурации следует посылать событие (например, `EVENT_DEVICE_CONFIG_CHANGED`), на которое подпишутся robot/laser/pictures, чтобы обновлять свои кэши без перезапуска.
